---
title:  Züchtungslehre - Übung 2
author: Peter von Rohr
date: 2017-10-06
output: 
  pdf_document:
    includes:
      in_header: header.tex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, results = 'asis')
```


## Aufgabe 1: Matrixdefinitionen in R
In R werden Matrizen mit der Funktion `matrix` erstellt. Diese aktzeptiert verschiedene Optionen in Form von Funktionsparametern. Wir wollen uns hier anschauen, welche Auswirkungen die verschiedenen Parameter auf die erzeugten Matrizen haben.  

__Ihre Aufgabe__ wird es sein die Matrizen mit den verschiedenen Optionen zu erstellen und so besser zu verstehen, was die Optionen für eine Bedeutung haben.

### Parameter `data`
* `data`: Angabe der Matrix-Elemente
<!-- Kopieren Sie die nachfolgende Anweisung an die Konsole oder -- 
  -- setzen sie eval=TRUE und machen eine Klammer um die gesamte --
  -- Anweisung, z.Bsp: (matA <- matrix(data = c(1:9), nrow = 3, ncol = 3)) --
  -- so erscheit die erzeugte Matrix als output                  -- 
  -->
```{r echo=TRUE, results='markup', eval=FALSE}
matA <- matrix(data = c(1:9), nrow = 3, ncol = 3)
```

* `data`: Ohne Angabe der Matrix-Elemente
```{r echo=TRUE, results='markup', eval=FALSE}
matB <- matrix(nrow = 3, ncol = 3)
```

* `data`: Spezifikation nicht aller Elemente
```{r echo=TRUE, results='markup', eval=FALSE}
matC <- matrix(data = c(1,2,3), nrow = 3, ncol = 3)
```

```{r echo=TRUE, results='markup', eval=FALSE}
matC2 <- matrix(data = c(1,2,3,4), nrow = 3, ncol = 3)
```

### Parameter `nrow` und `ncol`
* Weglassen einer der beiden Parameter

```{r echo=TRUE, results='markup', eval=FALSE}
matD <- matrix(data = c(1:9), nrow = 3)
```

```{r echo=TRUE, results='markup', eval=FALSE}
matE <- matrix(data = c(1:9), ncol = 3)
```

### Parameter `byrow`
```{r echo=TRUE, results='markup', eval=FALSE}
matF <- matrix(data = c(1:9), nrow = 3, ncol = 3, byrow = TRUE)
```

```{r echo=TRUE, results='markup', eval=FALSE}
matG <- matrix(data = c(1:9), nrow = 3, ncol = 3, byrow = FALSE)
```


## Aufgabe 2: Matrixmultiplikation in R
Matrixmultiplikationen können in R mit dem Operator `%*%` oder mit den Funktionen `crossprod()` oder `tcrossprod()` ausgeführt werden. Der Vorteil von `crossprod()` und `tcrossprod()` gegenüber von `%*%` ist, dass wir mit `crossprod()` und `tcrossprod()` direkt Matrizen und Vektoren multiplizieren können. Das funktioniert mit `%*%` nicht. Bei der Matrix-Vektor-Multiplikation mit `%*%` muss der Vektor zuerst in eine Matrix verwandelt werden. 

In einem ersten Teil der Aufgabe geht es um einen Vergleich zwischen `crossprod()`, `tcrossprod()` und `%*%` für die Matrix-Matrix-Multiplikation. 

a) Gegeben sind die folgenden Matrizen

```{r MatMultMatDef, echo=TRUE, results='markup'}
(matA <- matrix(data = c(1:9), ncol = 3))
(matB <- matrix(data = c(2:10), ncol = 3))
```

Finden Sie heraus welcher Multiplikationen mit `%*%` entspricht die folgende Anweisung?

```{r, echo=TRUE, results='markup', eval=TRUE}
crossprod(matA,matB)
```

<!-- Sie können hier einen neuen R-code-junk beginnen und die verschiedenen   --
  -- Multiplikationen ausprobieren. Dabei können Sie sowohl die Reihenfolge   --
  -- der Matrizen ändern und die Matrizen transponieren. Die Transponierte    -- 
  -- einer Matrix matA erhalten sie in R mit t(matA).                         --
  -- Die folgende Anweisung erzeugt einen neuen Code-Junk. Die R-Statements   --
  -- müssen zwischen auf den Zeilen zwischen den drei Backticks (```) stehen  --
  
```{r}

```
  -->

Alternativ dazu gibt es die Funktion `tcrossprod()`. Finden Sie, welche Matrixmultiplikation mit `%*%`

```{r, echo=TRUE, results='markup', eval=TRUE}
tcrossprod(matA, matB)
```

<!-- Analog zur Aufgabe oben mit crossprod(), hier das gleich für tcrossprod() -->

ausführt.

\pagebreak

b) Gegeben ist zusätzlich der Vektor `vecB` als

```{r, echo=TRUE}
vecB <- c(-3,16,1)
```

Multiplizieren Sie die Matrix `matA` mit dem Vektor `vecB` einmal mit `%*%` und einmal mit `crossprod()`.

__Hinweise__: Ein Vektor kann mit der Funktion `as.matrix()` in eine Matrix verwandelt werden.

<!-- Fügen Sie hier eine R-code-junk hinzu und multiplizieren Sie --
  -- hier die Matrix matA mit dem Vektor vecB                     --
  -->


## Aufgabe 3: Gleichungssysteme

Gegeben ist das folgende Gleichungssystem.

\begin{IEEEeqnarray}{rCl}
       2x_2 + 2x_3 &=& 1 \nonumber\\
2x_1 + 4x_2 + 5x_3 &=& 9 \nonumber\\
 x_1 -  x_2 + 2x_3 &=& 3
\label{eq:GlsA1} 
\end{IEEEeqnarray}

a) Bestimmen Sie die Lösungsmenge des Gleichungssystems (\ref{eq:GlsA1}) mit dem Gaussverfahren

<!-- Geben Sie hier die Schritte für die Bestimmung der Lösungsmenge mit dem Gaussverfahren      --
  -- Am einfachsten ist, wenn Sie das Gleichungssystem aus der Aufgabe kopieren und nachfolgend  --
  -- bei jedem Schritt des Gaussverfahrens wieder einfügen.                                      --
  -->

b) Verwandeln Sie das Gleichungssystem (\ref{eq:GlsA1}) in Matrix-Vektor-Schreibweise

<!-- Als Resultat erhalten Sie eine 3-mal-3-Matrix A, ein Vektor x und ein  --
  -- Vektor b, wobei beide Vektoren die Länge 3 aufweisen.                  --
  -- Die Matrix können Sie wie folgt angeben:                                      --
  --
$$A = \left[\begin{array}{ccc}
      &     &    \\
      &     &    \\
      &     &    \\
 \end{array}\right] $$
 
  -- Der Vektor x
$$x = \left[\begin{array}{c}
      \\
      \\
      \\
 \end{array}\right] $$
  
  -- Der Vektor b wird analog angegeben.                                  --
  --
$$b = \left[\begin{array}{c}
      \\
      \\
      \\
 \end{array}\right] $$
  
  -- -->

c) Wie lautet die Lösung des Gleichungssystem (\ref{eq:GlsA1}) in Matrix-Vektor-Schreibweise

<!-- Hier soll das Gleichungssystem von Aufgabe b) nach x  --
  -- aufgelöst werden. Somit lautet das Resultat           --
  
$$ x = $$  
  -->


d) Berechnen Sie die Lösung aus c) mit R

__Hinweis__: Für die Multiplikation der Matrix $A^{-1}$ mit dem Vektor $b$ muss der Vektor $b$ in eine Matrix verwandelt werden. Dies kann mit der Funktion `as.matrix()` gemacht werden.

<!-- Hier ist die Funktion solve() wichtig. Für nähere Hinweise kann auch  --
  -- die Hilfe mit ?solve von der Konsole aufgrufen werden.                --
  -->


## Aufgabe 4: Quantitative Genetik
In einer Population wurden für einen Genort folgende Häufigkeiten bei Genotypen gezählt

```{r GenotypeFreqs}
dfGenotypeFreq <- data.frame(Genotypen = c("$A_1A_1$", "$A_1A_2$", "$A_2A_2$"),
                             Anzahl    = c(24, 53, 23),
                             stringsAsFactors = FALSE)
knitr::kable(dfGenotypeFreq)
```

a) Bestimmen Sie die Genotypfrequenzen

<!-- Der Vektor der Anzahlen der Genotypen ist mit dfGenotypeFreq$Anzahl verfügbar. --
  -- Mit der Funktion sum() wird die Summe der Elemente in einem Vektor berechnet.  --
  -->

b) Bestimmen Sie die Allelfrequenzen

<!-- Anstelle der Genotypen werden hier die Frequenzen der Allele A1 und A2 --
  -- bestimmt.                                                              --
  -->

c) Berechnen Sie das Populationsmittel $\mu$ unter der Annahme, dass die genotypischen Werte zwischen den homozygoten Genotypen $20$ Einheiten auseinanderliegen und dass der heterozygote Genotyp einen genotypischen Wert von $2$ hat.

<!-- Das Populationsmittel entspricht dem Erwartungswert und dieser berechnet --
  -- sich aus Frequenz der Genotypen mal Wert dem genotypischen Wert          --
  -->
